Fully Homomorphic Encryption (FHE) has been referred as the ``holy grail'' of modern cryptography as it was one of the most sought goals for the past couple of decades. First formally introduced by Rivest, Adleman and Dertouzos in \cite{primal} (at the time called ``privacy homomorphism''), shortly after the discovery of public key cryptography, it has been an open and elusive problem. Only ``recently'', in~2009, Craig Gentry proposed first FHE in his PhD thesis \cite{gentry_phd}. Since then, there has been a lot of development in the area like for example \krzys{TODO: finish developments of fhe}.

Simply stated, in homomorphic encryption we want our data to be secure but we also want to perform calculations on it. This is useful when you need a third party (e.g. someone with more computational power) to perform operations on your data while still retaining privacy. Alice can store her data somewhere on external server (the cloud) and ask to perform computations on it. For example query searches without the engine knowing what is actually being searched for.

In other words, we would like our encryption scheme to satisfy the following. Say the ciphertexts $c_i$'s decrypt to messages $m_i$'s. Then we want
$$ \alg{Decrypt}_{\E}(c_1 + c_2) = m_1 + m_2, \qquad \alg{Decrypt}_{\E}(c_1*c_2) = m_1*m_2$$
Equivalently, we want $\alg{Decrypt}$ to be a ring homomorphism. $\E$ being \textit{fully homomorphic} means that whenever $f$ is a composition of \textbf{arbitrily many} additions and multiplications, then $\alg{Decrypt}_{\E}(f(c_1, \dots, c_n)) = f(m_1, \dots, m_n)$\footnote{There are two more technical requitements, namely \textit{compactness of the ciphertexts} and \textit{efficiency} but we will not consider them in this paper.} which is also refered to as the \textit{correctness} of the scheme.

\begin{remark} \label{algs}
    Typically, an encryption scheme $\mathcal{E}$ is a tuple of $\alg{KeyGen}_{\E}$, $\alg{Encrypt}_{\E}$ and $\alg{Decrypt}_{\E}$ (representing the key-generation, encryption and decryption respectively), all of which we require to be \textit{efficient} - i.e. run in time poly($\lambda$) - polynomial in the security parameter $\lambda$ that represents the bit-length of the keys (see for example \cite{katz} or \cite{book} for more details on the abstract build of a encryption scheme). A homomorphic encryption scheme has a fourth algorithm - $\alg{Evaluate}_{\E}$ which we associate with some set of \textit{permitted functions}. In our case this will simply be $\alg{Add}_{\E}$ and $\alg{Mult}_{\E}$ which we will introduce in further sections. Adopting the notation from \cite{easy_fhe} we will denote by $\mathcal{F}_{\E}$, the generalized set of such functions.
\end{remark}

\subsection{Somewhat Homomorphic Encryption}\label{int_she}
Before we introduce the solution on to how to construct such FHE presented by Gentry, we will start with something slightly simpler, introduced in \cite{int_scheme} by van Dijk et al. Their scheme works over the integers rather than lattices but relies on a similar assumption. Namely, that finding the greatest common divisor of many ``noisy'' multiples of a number is computationally difficult. We will come back to this problem later. To keep the exposition compact, we will avoid specifying most parameter choices.

\subsubsection*{Symmetric Key Scheme}
We begin with the symmetric key scheme. We take our message to be a bit $m \in \{0,1\}$. The private key is an odd integer $p$ (no necessarily prime). To encrypt our message $m$, we choose integers $q$ and $r$ at random (such that the magnitude of $2r$ is smaller than $p/2$). We obtain the ciphertext $c$ by computing: 
\begin{equation}c = pq + 2r + m.\end{equation}
If we now want to decrypt our message, simply compute $(c \mod p) \mod 2$. \\
Let's say we have two messages $c_1$ and $c_2$. Then we can compute:
$$ c_1 + c_2 = m_1 + m_2 + 2(r_1 + r_2) + p(q_1 + q_2),$$
$$ c_1 * c_2 = m_1 * m_2 + 2(m_1r_2 + m_2r_1 + 2r_1r_2) + p(m_1q_2 + m_2q_1 + 2(r_1q_2 + r_2q_1) + pq_1q_2)$$
where we can see that the noise grows with each operation and the message becomes impossible to decrypt after we do too many of them. If we can assure that $2(m_1r_2 + m_2r_1 + 2r_1r_2)$ is small enough - i.e. smaller than $p$\footnote{When $2r > p$ then it might be the case that $2r = 1 \mod p$ and so $pq + 2r + m \mod p = 1 + m \neq m$.} - then we can assure that $\alg{Decrypt}(c_1 * c_2)$ evaluates correctly to the starting $m_1 * m_2$. Notice that $\alg{Decrypt}$ removes all the noise. This will be useful later for ``bootstrapping'' - a term introduced later on.

This simple encryption scheme is thus somewhat homomorphic as per definition by Gentry in \cite{gentry_phd} â€“ namely, it can be used to evaluate low-degree polynomials over encrypted data. Further on in the Section 6 of \cite{int_scheme}, van Dijk et al. use the techniques (called bootstrapping and squashing) to lift it to a Fully Homomorphic Scheme.
\subsubsection*{Public Key Scheme}
The public key scheme is build very similarly. The private key $p$ stays the same. For the public key, sample $x_i = p q_i + 2r_i$ for $i = 0, 1, \dots, t$ where the $q_i$ and $r_i$ stay as before. The $x_i$ may be viewed as encryption of 0 under the symmetric key scheme. The $x_i$ are now taken s.t. $x_0$ is the largest, odd and $x_0 \mod p$ is even.

To now encrypt a message $m \in \{0,1\}$, chose a random subset $S \subseteq \{1, 2, \dots, t\}$ and a random integer $r$, and output
\begin{equation} c = (m + 2r + 2\sum_{i \in S} x_i) \mod x_0.\end{equation}
To decrypt, we again output $m = (c \mod p) \mod 2$.

The security of this preliminary SH scheme relies on the \textit{Approximate GCD Problem}\footnote{Later in \cite{revisited}, a reduction was constructed to LWE. This means, that under few more assumptions, this problem (and by extension any scheme based on it) is as secure as one based on LWE.}. In the simplest case, Euclid has shown us, that given two integers $c_1$ and $c_2$, it is easy to compute their $\gcd$. However, suppose now that $c_1 = p \cdot q_1 + r_1$ and $c_2 = p \cdot q_2 + r_2$ are ``near'' multiples of $p$, where $r_1$ and $r_2$ is some small noise sampled at random. This turns out to be much more difficult. In fact, if we pick our values appropriately (see \cite{easy_fhe} Section 3.4 and \cite{int_scheme} Section 3 for details) we do not know any efficient (running in polynomial time) algorithm even if we are given arbitrarily many samples $c_i = r_i + p \cdot q_i$.

However, this comfortable security comes at great cost because, as shown in \cite{int_scheme}, the parameters chosen to assure the secrecy, yield a scheme that has complexity of $\tilde{O}(\lambda^{10})$ where $\lambda$ is our security parameter (the greater it is the more secure message). As a small example, consider $\lambda = 10$ as the (small) key size. To now encrypt a single(!) bit, it will take approximately $10^{10}$ operations. On a modern laptop this would take a little less than 5 seconds. To send the message `hello', we need to use 5 letters $\cdot$ 16-bits per letter $= 5\cdot 16\cdot5 = 650$ seconds which is almost 11 minutes! As one can imagine, this is completely impractical for most applications.

\subsection{Fully Homomorphic Encryption}
We will now present the main idea introduced in Gentry's PhD thesis \cite{gentry_phd}. Namely, how can we make use of ideal lattices to create a encryption scheme that can handle an arbitrary amount of functions. We will proceed in parallel with the original by introducing the idea of ``bootstrapping'', through a construction of a suitable SH scheme (this is where the ideal lattices show up) and finishing with the ``squashing''.

\subsubsection{Boostrapping}
We are faced with a problem. Because our method relies on some error being added to the message, it builds up after we perform operations on our data. The scheme $\E$ can handle functions in a limited set $\mathcal{F}_{\E}$ until the noise becomes too large. Is there a way for us to somehow expand this set and yet retain the homomorphic properties of the scheme? Can we, further on, expand this set to include an arbitrary polynomial function? The answer turns out to be yes. As shown by Gentry, one of the requirements for this is that the scheme can decrypt its encryption correctly ``and some''. A bit more formally, we require that the $\alg{Decrypt}_{\E} \in \mathcal{F}_{\E}$. This part will be a brief explanation of what the bootstrapping is and how we can achieve it using (also introduced in the same paper) ``squashing''.

\begin{remark}
  In cryptography, which is a field in the intersection of mathematics and computing science, instead of general functions, one often considers a \textit{circuit} instead. Roughly speaking, a circut is a translation of what a mathematician thinks when they say ``function''. It consists of (finite amount) of gates which are just boolean functions. For example there is a $\alg{NOT}$ gate that takes a bit $b \in \{0,1\}$ and outputs $b + 1$, where all the operations are performed modulo 2. Others include for example $\alg{XOR}$ - this is an exclusive logical $\alg{OR}$ - or $\alg{NAND}$ which is a $\alg{AND}$ followed up by a $\alg{NOT}$ gate. From a theoretical point of view, one can use solely a $\alg{NAND}$ gate to represent any circuit and thus we will be mostly concerned with that one.
\end{remark}

Imagine we have a SH scheme $\E$ (one can think of the one from previous section as a concrete example) that is correct for its own decryption circuit augumented by an $\alg{NAND}$ gate. We call such scheme \textit{bootstrappable}. As shown in the paper, one can use this circuit to create a (leveled) fully homomorphic encryption $\E^{(d)}$. It is called \textit{leveled} because the correctnes depends on the ``depth'' (or the level) $d$ of the circuit making it depend on $d$. It can be show that by appropriately augumenting the public key, such leveled scheme can be made independent of depth and thus made into a \textit{fully homomorphic} one. Moreover, if the scheme itself is secure\footnote{The precise security mentioned is the semantic security against chosen plaintext attacks. One can think of it as requiring that the same message $m$ has different outputs $c$ on different runs of the same encryption algorithm (it is non-deterministic). See \cite{katz} or \cite{lattice-survey} for a precise definition.}, then so is any $\alg{Evaluate}_{\E^(d)}$ algorithm. All of this is captured in the following theorem.

\begin{theorem}[\cite{gentry}]
  One can construct a (semantically secure) family $\{ \E^{(d)} \}$ of leveled fully homomorphic encryption schemes from any (semantically secure) bootstrappable encryption scheme $\E$.
\end{theorem}

Why is this the correct requirement for a FHE? Suppose that there is an ``error'' associated with each ciphertext, just like in the scheme from Section \ref{int_she}. Then as noted there, after we perform one operations too many, the error builds up soo much that we are no longer able to decrypt correctly. We would therefore like to somehow make the error small enough again and ``refresh'' the ciphertext without using the secret key. Clearly we could get rid of the error completely if we were to decrypt it and create a ``fresh'' ciphertext of the same message. This is the precisely the idea, to decrypt the message but do it homomorphically! We obtain a homomorphic encryption by encrypting homomorphically - we are bootstrapping. One idea on how to do it, is by appending the encryption of the secret key in the public key. This is the aforementioned ``squashing'' introduced more formally later.

\begin{remark}
Note that this requires another assumption called ``circular security'' or KDM (Key Dependent Message) security. That is, we are assuming that the publication of the encryption of a secret key does not leak any valuable information about the key itself. This is however very difficult to prove in practice but also no known attacks are know and hence it is just assumed along.
\end{remark}

To do this, we introduce an algorithm called $\alg{Recrypt}$. Imagine we have a ciphertext $c_1$ that we want to refresh. \krzys{finish if there is time, include the need for a NAND gate as the "progress" in the circuit}.

\subsubsection{Simple lattice based scheme}
The motivation for the choice of lattices as opposed to number theoretic constructions (like RSA or ElGamma for example which are based on expontiation), is that the former has some desirable properties. Firstly, the lattices have lower decryption complexity and are therefore more suitable as a bootstrappable encryption scheme. Next, one requires not only one supported homomorphism like addition but also the multiplication - lattices as ideals poses both. Those factors among many others, (see \cite{gentry} for more details) have led to the choice of \textit{ideal lattices}.

The idea behind the encryption is somewhat similar to the one of GGH. That is, we are going to fix a basis for a lattice (which is an ideal), publish the bad basis as the public key and keep the good basis as a secret key. The security of this scheme is based on the Ideal Coset Problem (\prob{ICP}) introduced momentarily. Briefly stated, given an element of some ring $t \in R$, the \prob{ICP} asks us to find a distinguishable representative of a coset of some fixed ideal in an arbitrary ring.

\begin{definition}[Informal]
  Fix a ring $R$ along with an ideal $I \subseteq R$ and pick some element $r \in R$. Now pick a basis $\B_I$ for the ideal $I$. The challenger is asked to distinguish between $t \equiv r \mod \B_I$ and $t$ being chosen uniformly.
\end{definition}
Few remarks are in place now. Firstly, this definition hides few details in favour of clearer notation. As one, we actually fix some ideal $J \subseteq R$ such that $I$ and $J$ are coprime (i.e. $I + J = R$) first, and then, with respect to such $J$, we instantiate the $I$. This will become evident later in this section why this is required. Secondly, the procedure somewhat depends on the efficiency of those choices. One example would be how to pick such coprime ideals (an issue addressed also in later sections) as well as how to sample the $r$ from the ring itself. The questions (partially) are answered in the paper \cite{gentry_phd} itself.

\subsubsection{Squashing}
\subsubsection{Limitations}

\subsection{Further developments in FHE}
Since the inception of FHE, many new ideas have emerged as potential replacement for the details in the implementation in Gentry's work. In this section, we will briefly introduce some of such techniques and ideas. Finally the work we have done on LWE and its ring equivalent will pay off as we will be able to treat them almost as a black box

\subsubsection{FHE from the standard LWE}
 One of such ideas is to replace the ideal lattices (which poses more structure than regular lattices and are thus possibly more prone to new attacks) by an LWE sample instead.


 Let us now attempt to construct a SH scheme that is using the LWE assumption along the ideas presented in \cite{fhe-lwe}. Recall that a LWE$_{q, \chi}$ is specified by the odd modulus $q > 2$ and error distribution $\chi$. It provides us with the LWE distribution that we called $A_{s, \chi}$ where $\bm{s}$ was a random vector representing the secret key outputting us samples of the form
\[A_{s, \chi} \rightarrow (\bm{a}, b) = (\bm{a}, \langle \bm{a}, \bm{s} \rangle + e)\],
where $e$ was drawn from some distribution $\chi$ (usually taken to be the discrete Gaussian distribution with small standard deviation) over $\Z_q$ for $q$ prime\footnote{Since we will be using the decision version of the problem, we need to assume $q$ to be prime.}. We can now imagine a scheme that works as follows: to encrypt a single bit $m \in \{0,1\}$ using a secret key $\bm{s}$, draw a sample from $A_{s, \chi}$ and output the ciphertext
\[ c \; = \; (\bm{a}, b = \langle \bm{a}, \bm{s} \rangle +2e +m) \; \; \; \in \Z_q^n \cross \Z_q \]
Note that we have replaced the error $e$ with its two-times multiple in contrast to the original formulation by Regev as can be seen in Table \ref{lwe-enc}. This is not a problem at all because 2 and $q$ are coprime. To decrypt the message, first compute $\langle \bm{a},\bm{s} \rangle$ and substract that from $b$, giving $2e + m \mod q$ which, since $e \ll q$, is actually equal to $2e +m$ exactly. Finally, reduce modulo 2 and we are left with the original message $m$.

The scheme is clearly additively homomorphic. The issue arises when we try to multiply two ciphertexts. As shown in \cite{one-mult}, the (slight variation of) this scheme supports only a \textit{single} homomorphic multiplication with the expense of huge blowup in the ciphertext size.

To see how this is the case, consider a symbolic function $f_{\bm{a},b} : \Z_q^n \rightarrow \Z_q$ defined as:
\[f_{\bm{a}, b}(\bm{x}) = b - \langle \bm{a, x} \rangle \mod q = b - \bm{a}_i \bm{x}^i \; \; \; \in \Z_q \]
where we are using Eisenstein notation to represent elements $\bm{x} \in \Z_q^n$ (the transpose of the first element is implicit). Note now that the decryption is nothing else but evaluating this function on the secret key $\bm{s}$ and taking the result modulo 2. We can now define addition and multiplication using this function. Addition is straightforward, $f_{\bm{a}, b}$ is a linear function and so sum of two linear functions is still linear. Symbolically, $f_{\bm{a},b}(\bm{x}) + f_{\bm{a}',b'}(\bm{x}) = f_{(\bm{a}+\bm{a}',b+b')}(\bm{x})$ will represent the homomorphically added ciphertext $(\bm{a}+\bm{a}',b+b')$. Similarly, multiplying two such functions gives us
\begin{equation}\label{mult}
  \begin{split}
  f_{\bm{a},b}(\bm{x}) \cdot f_{\bm{a}',b'}(\bm{x}) & = ( b - \bm{a}_i \bm{x}^i) \cdot ( b' - \bm{a}'_i \bm{x}^i ) \\
						    & = h_0 + h_i \cdot \bm{x}^i + h_{i,j} \cdot \bm{x}^i \bm{x}^j,
\end{split}
\end{equation}
which yields us a second degree polynomial with coefficients $h_{i,j}$ that can be computed by expanding the parenthesis of the upper equation. The decryption is as before, that is evaluating at $\bm{s}$ and reducing modulo 2. Hence, the scheme is trully homomorphic. Unfortunately, nothing in life comes for free and indeed, the multiplication which took a ciphertexts of size $n+1$, expanded it to the one of size approximately $n^2/2$. As one might imagine this is completely unacceptable from an efficiency point of view and surely not enough for bootstrapping. This is where the main contribution of \cite{fhe-lwe} comes in - the \textit{re-linearization} technique.
\paragraph{Re-linearization}
The goal is to reduce the ciphertext blow-up for multiplication. As turns out we can actually reduce the result back to just a $n+1$ size assuming something that resembles KDM security or ``circular security'' - i.e. we need to assume that the encryption of a secret key does not leak any information about it. However, the key difference is that we encrypt all of the linear and quadratic terms of $\bm{s}$ but using a different key, call it $\bm{t}$. More precisely, we encrypt numbers $\bm{s}^i$ as well as $\bm{s}^{i,j}$ using the new secret key $\bm{t}$. The adjusted equation \ref{mult} with $\bm{s}$ plugged in for $\bm{x}$ now (approximately) looks like: 
\begin{align*}
  %b^i = \langle \bm{a}^i, \bm{t} \rangle + 2e^i +\bm{s}^i \approx \langle \bm{a}^i, \bm{t} \rangle + \bm{s}^i \\
  %b^{i,j} = \langle \bm{a}^{i,j}, \bm{t} \rangle + 2e^{i,j} +\bm{s}^{i,j} \approx \langle \bm{a}^{i,j}, \bm{t} \rangle + \bm{s}^{i,j} \\
  & h_0 + h_i \cdot \bm{s}^i + h_{i,j} \cdot \bm{s}^i \bm{s}^j\\
  = \; \; & h_0 + h_i \cdot (b^i - \langle \bm{a}^i, \bm{t} \rangle) + h_{i,j} \cdot (b^{i,j} - \langle \bm{a}^{i,j}, \bm{t} \rangle), 
\end{align*}
which is just a linear function in $\bm{t}$! The key take-away is that multiplying the two linear functions and later re-linearizing, gives us another linear function that when evaluated in $\bm{t}$, outputs the product of the original messages.

\subsubsection{FHE from the ring-LWE}
A step forward in losing the need for
\subsubsection{Other works}
