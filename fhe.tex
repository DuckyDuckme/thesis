Fully Homomorphic Encryption (FHE) has been referred as the ``holy grail'' of modern cryptography as it was one of the most sought goals for the past couple of decades. First formally introduced by Rivest, Adleman and Dertouzos in \cite{primal} (at the time called ``privacy homomorphism''), shortly after the discovery of public key cryptography, it has been an open and elusive problem. Only ``recently'', in~2009, Craig Gentry proposed first FHE in his PhD thesis \cite{gentry_phd}. Since then, there has been a lot of development in the area like for example \krzys{TODO: finish developments of fhe}.

Simply stated, in homomorphic encryption we want our data to be secure but we also want to perform calculations on it. This is useful when you need a third party (e.g. someone with more computational power) to perform operations on your data while still retaining privacy. Alice can store her data somewhere on external server (the cloud) and ask to perform computations on it. For example query searches without the engine knowing what is actually being searched for.

In other words, we would like our encryption scheme to satisfy the following. Say the ciphertexts $c_i$'s decrypt to messages $m_i$'s. Then we want
$$ \alg{Decrypt}_{\E}(c_1 + c_2) = m_1 + m_2, \qquad \alg{Decrypt}_{\E}(c_1*c_2) = m_1*m_2$$
Equivalently, we want $\alg{Decrypt}$ to be a ring homomorphism. $\E$ being \textit{fully homomorphic} means that whenever $f$ is a composition of \textbf{arbitrily many} additions and multiplications, then $\alg{Decrypt}_{\E}(f(c_1, \dots, c_n)) = f(m_1, \dots, m_n)$\footnote{There are two more technical requitements, namely \textit{compactness of the ciphertexts} and \textit{efficiency} but we will not consider them in this paper.} which is also refered to as the \textit{correctness} of the scheme.

\begin{remark} \label{algs}
    Typically, an encryption scheme $\mathcal{E}$ is a tuple of $\alg{KeyGen}_{\E}$, $\alg{Encrypt}_{\E}$ and $\alg{Decrypt}_{\E}$ (representing the key-generation, encryption and decryption respectively), all of which we require to be \textit{efficient} - i.e. run in time poly($\lambda$) - polynomial in the security parameter $\lambda$ that represents the bit-length of the keys (see for example \cite{katz} or \cite{book} for more details on the abstract build of a encryption scheme). A homomorphic encryption scheme has a fourth algorithm - $\alg{Evaluate}_{\E}$ which we associate with some set of \textit{permitted functions}. In our case this will simply be $\alg{Add}_{\E}$ and $\alg{Mult}_{\E}$ which we will introduce in further sections. Adopting the notation from \cite{easy_fhe} we will denote by $\mathcal{F}_{\E}$, the generalized set of such functions.
\end{remark}

\subsection{Somewhat Homomorphic Encryption}\label{int_she}
Before we introduce the solution on to how to construct such FHE presented by Gentry, we will start with something slightly simpler, introduced in \cite{int_scheme} by van Dijk et al. Their scheme works over the integers rather than lattices but relies on a similar assumption. Namely, that finding the greatest common divisor of many ``noisy'' multiples of a number is computationally difficult. We will come back to this problem later. To keep the exposition compact, we will avoid specifying most parameter choices.

\subsubsection*{Symmetric Key Scheme}
We begin with the symmetric key scheme. We take our message to be a bit $m \in \{0,1\}$. The private key is an odd integer $p$ (no necessarily prime). To encrypt our message $m$, we choose integers $q$ and $r$ at random (such that the magnitude of $2r$ is smaller than $p/2$). We obtain the ciphertext $c$ by computing: 
\begin{equation}c = pq + 2r + m.\end{equation}
If we now want to decrypt our message, simply compute $(c \mod p) \mod 2$. \\
Let's say we have two messages $c_1$ and $c_2$. Then we can compute:
$$ c_1 + c_2 = m_1 + m_2 + 2(r_1 + r_2) + p(q_1 + q_2),$$
$$ c_1 * c_2 = m_1 * m_2 + 2(m_1r_2 + m_2r_1 + 2r_1r_2) + p(m_1q_2 + m_2q_1 + 2(r_1q_2 + r_2q_1) + pq_1q_2)$$
where we can see that the noise grows with each operation and the message becomes impossible to decrypt after we do too many of them. If we can assure that $2(m_1r_2 + m_2r_1 + 2r_1r_2)$ is small enough - i.e. smaller than $p$\footnote{When $2r > p$ then it might be the case that $2r = 1 \mod p$ and so $pq + 2r + m \mod p = 1 + m \neq m$.} - then we can assure that $\alg{Decrypt}(c_1 * c_2)$ evaluates correctly to the starting $m_1 * m_2$. Notice that $\alg{Decrypt}$ removes all the noise. This will be useful later for ``bootstrapping'' - a term introduced later on.

This simple encryption scheme is thus somewhat homomorphic as per definition by Gentry in \cite{gentry_phd} â€“ namely, it can be used to evaluate low-degree polynomials over encrypted data. Further on in the Section 6 of \cite{int_scheme}, van Dijk et al. use the techniques (called bootstrapping and squashing) to lift it to a Fully Homomorphic Scheme.
\subsubsection*{Public Key Scheme}
The public key scheme is build very similarly. The private key $p$ stays the same. For the public key, sample $x_i = p q_i + 2r_i$ for $i = 0, 1, \dots, t$ where the $q_i$ and $r_i$ stay as before. The $x_i$ may be viewed as encryption of 0 under the symmetric key scheme. The $x_i$ are now taken s.t. $x_0$ is the largest, odd and $x_0 \mod p$ is even.\\
To now encrypt a message $m \in \{0,1\}$, chose a random subset $S \subseteq \{1, 2, \dots, t\}$ and a random integer $r$, and output
\begin{equation} c = (m + 2r + 2\sum_{i \in S} x_i) \mod x_0.\end{equation}
To decrypt, we again output $m = (c \mod p) \mod 2$.

The security of this preliminary SH scheme relies on the \textit{Approximate GCD Problem}\footnote{Later in \cite{revisited}, a reduction was constructed to LWE. This means, that under few more assumptions, this problem (and by extension any scheme based on it) is as secure as one based on LWE.}. In the simplest case, Euclid has shown us, that given two integers $c_1$ and $c_2$, it is easy to compute their $\gcd$. However, suppose now that $c_1 = p \cdot q_1 + r_1$ and $c_2 = p \cdot q_2 + r_2$ are ``near'' multiples of $p$, where $r_1$ and $r_2$ is some small noise sampled at random. This turns out to be much more difficult. In fact, if we pick our values appropriately (see \cite{easy_fhe} Section 3.4 and \cite{int_scheme} Section 3 for details) we do not know any efficient (running in polynomial time) algorithm even if we are given arbitrarily many samples $c_i = r_i + p \cdot q_i$.

However, this comfortable security comes at great cost because, as shown in \cite{int_scheme}, the parameters chosen to assure the secrecy, yield a scheme that has complexity of $\tilde{O}(\lambda^{10})$ where $\lambda$ is our security parameter (the greater it is the more secure message). As a small example, consider $\lambda = 10$ as the (small) key size. To now encrypt a single(!) bit, it will take approximately $10^{10}$ operations. On a modern laptop this would take a little less than 5 seconds. To send the message `hello', we need to use 5 letters $\cdot$ 16-bits per letter $= 5\cdot 16\cdot5 = 650$ seconds which is almost 11 minutes! As one can imagine, this is completely impractical for most applications.

\subsection{Fully Homomorphic Encryption}
We will now present the main idea introduced in Gentry's PhD thesis \cite{gentry_phd}. Namely, how can we make use of idea lattices to create a encryption scheme that can handle an arbitrary amount of functions.

\subsubsection*{Boostrapping}
We are faced with a problem. Because our method relies on some error being added to the message, it builds up after we perform operations on our data. The scheme $\E$ can handle functions in a limited set $\mathcal{F}_{\E}$ until the noise becomes too large. Is there a way for us to somehow expand this set and yet retain the homomorphic properties of the scheme? Can we, further on, expand this set to include an arbitrary polynomial function? The answer turns out to be yes. As shown by Gentry, one of the requirements for this is that the scheme can decrypt its encryption correctly ``and some''. This part will be a brief explanation of what the bootstrapping is and how we can achieve it using (also introduced in the same paper) ``squashing''.

\begin{remark}
  In cryptography, which is a field in the intersection of mathematics and computing science, instead of general functions, one often considers a \textit{circuit} instead. Roughly speaking, a circut is a translation of what a mathematician thinks when they say ``function''. It consists of (finite amount) of gates - they are just boolean functions. For example there is a $\alg{NOT}$ gate that takes a bit $b \in \{0,1\}$ and outputs $b + 1$, where all the operations are performed modulo 2. Others include for example $\alg{XOR}$ - this is an exclusive logical $\alg{OR}$ - or $\alg{NAND}$ which is a $\alg{AND}$ followed up by a $\alg{NOT}$ gate. From a theoretical point of view, one can use solely a $\alg{NAND}$ gate to represent any circuit and thus we will be mostly concerned with that one.
\end{remark}

Imagine we have a SH scheme $\E$ (one can think of the one from previous section as a concrete example) that is correct for its decryption circuit augumented by an $\alg{NAND}$ gate. We call such scheme \textit{bootstrappable}. As shown in the paper, one can use this circuit to create a (leveled) fully homomorphic encryption $\E^{(d)}$. It is called \textit{leveled} because the correctnes depends on the ``depth'' (or the level) $d$ of the circuit making it depend on $d$. It can be show that by appropriately augumenting the public key, such leveled scheme can be made independent of depth and thus made into a \textit{fully homomorphic} one. Moreover, if the scheme itself is secure\footnote{The precise security mentioned is the semantic security agains chosen plaintext attacks.}, then so is any $\alg{Evaluate}_{\E^(d)}$ algorithm.

Why is this the correct requirement for a FHE? Supposed that there is an ``error'' associated with each ciphertext, just like in the scheme from previous part. Then as noted there, after we perform one operations too many, the error builds up soo much that we are no longer able to decrypt correctly. We would therefore like to somehow make the error small enough again and ``refresh'' the ciphertext without using the secret key. Clearly we could get rid of the error completely if we were to decrypt it and create a ``fresh'' ciphertext of the same message. This is precisely the idea behind bootstrapping, to decrypt the message but do it homomorphically! An idea on how to do it, is by appending the encryption of the secret key in the public key.

\begin{remark}
Note that this requires another assumption called ``circular security'' or KDM (Key Dependent Message) security. That is, we are assuming that the publication of the encryption of a secret key does not leak any valuable information about the key itself. This is however very difficult to prove in practice but also no known attacts are know and hence it is just assumed along.
\end{remark}

To do this, we introduce an algorithm called $\alg{Recrypt}$. Imagine we have a ciphertext $c_1$ that we want to refresh. \krzys{finish if there is time, include the need for a NAND gate as the "progress" in the circuit}.

\subsubsection*{Lattice based scheme}
The motivation for the choice of lattices as opposed to number theoretic constructions (like RSA or ElGamma for example), is that the former has lower decryption complexity and is therefore more suitable as a bootstrappable encryption scheme. Additionally, one requires not only one supported homomorphism like addition but also the multiplication. Those factors (among others, see \cite{gentry} for more details) has led to the choice of \textit{ideal lattices}.

The idea behind the encryption is similar to the one of GGH. That is, we are going to fix a lattice and publish a bad basis as the public key and keep a good basis as a secret key. Let us then fix some ring $R$
